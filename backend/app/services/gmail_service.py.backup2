"""
Gmail service for OAuth2 authentication and email operations.
Follows Single Responsibility Principle - handles only Gmail operations.
Automatically clears sessions on startup for fresh authentication.
"""
import os
import json
import base64
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import Flow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

from app.models.email_models import EmailContent, EmailDomain, DomainAnalysis, EmailPriority
from app.core.config import get_settings
from app.core.exceptions import EmailProcessingException, InvalidEmailDomainException


class GmailService:
    """
    Gmail service for OAuth2 authentication and email operations.
    Automatically clears sessions on startup for fresh authentication.
    """
    
    def __init__(self):
        """Initialize Gmail service and clear any existing sessions."""
        self.credentials_file = "gmail_credentials.json"
        self.token_file = "gmail_token.json"
        self.service = None
        self.settings = get_settings()
        
        # Clear any existing sessions on startup
        self._clear_sessions()
    
    def _clear_sessions(self):
        """Clear all stored credentials and sessions."""
        try:
            files_to_remove = [self.credentials_file, self.token_file]
            for file_path in files_to_remove:
                if os.path.exists(file_path):
                    os.remove(file_path)
                    print(f"🗑️ Cleared session file: {file_path}")
            print("✅ All Gmail sessions cleared - fresh authentication required")
        except Exception as e:
            print(f"⚠️ Warning: Could not clear some session files: {e}")
    
    def _load_existing_credentials(self):
        """Load existing credentials if available."""
        if os.path.exists(self.token_file):
            try:
                creds = Credentials.from_authorized_user_file(self.token_file, self.settings.gmail_scopes)
                if creds and creds.valid:
                    self.service = build('gmail', 'v1', credentials=creds)
                elif creds and creds.expired and creds.refresh_token:
                    creds.refresh(Request())
                    self.service = build('gmail', 'v1', credentials=creds)
                    self._save_credentials(creds)
                else:
                    print(f"Invalid credentials: missing refresh_token or invalid state")
                    # Delete invalid token file to force re-authentication
                    os.remove(self.token_file)
            except Exception as e:
                print(f"Error loading existing credentials: {e}")
                # Clean up corrupted token file
                if os.path.exists(self.token_file):
                    os.remove(self.token_file)
    
    def _create_credentials_file(self):
        """Create Gmail OAuth2 credentials file."""
        if not self.settings.gmail_client_id or not self.settings.gmail_client_secret:
            raise EmailProcessingException("Gmail OAuth2 credentials not configured")
        
        credentials = {
            "web": {
                "client_id": self.settings.gmail_client_id,
                "client_secret": self.settings.gmail_client_secret,
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token",
                "redirect_uris": [self.settings.gmail_redirect_uri]
            }
        }
        
        with open(self.credentials_file, 'w') as f:
            json.dump(credentials, f, indent=2)
    
    def _save_credentials(self, creds: Credentials):
        """Save credentials to file."""
        with open(self.token_file, 'w') as f:
            f.write(creds.to_json())
    
    def get_auth_url(self) -> str:
        """Get Gmail OAuth2 authorization URL."""
        if not self.settings.gmail_client_id or not self.settings.gmail_client_secret:
            raise EmailProcessingException("Gmail OAuth2 credentials not configured")
        
        # Create credentials file if not exists
        if not os.path.exists(self.credentials_file):
            self._create_credentials_file()
        
        flow = Flow.from_client_secrets_file(
            self.credentials_file,
            scopes=self.settings.gmail_scopes,
            redirect_uri=self.settings.gmail_redirect_uri
        )
        
        auth_url, _ = flow.authorization_url(
            access_type='offline',
            include_granted_scopes='true',
            prompt='consent',  # Force consent screen to get refresh token
            login_hint=None
        )
        
        return auth_url
    
    def authenticate_with_code(self, auth_code: str) -> bool:
        """Authenticate with authorization code and save credentials."""
        try:
            if not os.path.exists(self.credentials_file):
                self._create_credentials_file()
            
            flow = Flow.from_client_secrets_file(
                self.credentials_file,
                scopes=self.settings.gmail_scopes,
                redirect_uri=self.settings.gmail_redirect_uri
            )
            
            flow.fetch_token(code=auth_code)
            creds = flow.credentials
            
            # Save credentials
            self._save_credentials(creds)
            
            # Initialize service
            self.service = build('gmail', 'v1', credentials=creds)
            
            return True
            
        except Exception as e:
            raise EmailProcessingException(f"Failed to authenticate: {str(e)}")
    
    def is_authenticated(self) -> bool:
        """Check if Gmail service is authenticated."""
        return self.service is not None
    
    def get_user_profile(self) -> Dict[str, Any]:
        """Get user profile information."""
        if not self.is_authenticated():
            raise EmailProcessingException("Not authenticated with Gmail")
        
        try:
            profile = self.service.users().getProfile(userId='me').execute()
            return {
                "email": profile.get('emailAddress'),
                "messages_total": profile.get('messagesTotal', 0),
                "threads_total": profile.get('threadsTotal', 0)
            }
        except HttpError as e:
            raise EmailProcessingException(f"Failed to get user profile: {str(e)}")
    
    def get_emails(self, max_results: int = 100) -> List[EmailContent]:
        """Fetch emails from Gmail."""
        if not self.is_authenticated():
            raise EmailProcessingException("Not authenticated with Gmail")
        
        try:
            # Get list of messages
            results = self.service.users().messages().list(
                userId='me',
                maxResults=max_results
            ).execute()
            
            messages = results.get('messages', [])
            emails = []
            
            for message in messages:
                try:
                    # Get full message details
                    msg = self.service.users().messages().get(
                        userId='me',
                        id=message['id']
                    ).execute()
                    
                    # Extract email data
                    headers = msg['payload'].get('headers', [])
                    email_data = {}
                    
                    for header in headers:
                        name = header['name'].lower()
                        if name in ['subject', 'from', 'to', 'date']:
                            email_data[name] = header['value']
                    
                    # Extract body
                    body = self._extract_body(msg['payload'])
                    
                    if email_data.get('from') and email_data.get('subject'):
                        # Parse date
                        date_str = email_data.get('date', '')
                        try:
                            from email.utils import parsedate_to_datetime
                            received_date = parsedate_to_datetime(date_str)
                        except:
                            received_date = datetime.now()
                        
                        # Extract domain from sender
                        sender_email = email_data['from']
                        domain = sender_email.split('@')[-1] if '@' in sender_email else 'unknown'
                        
                        email_content = EmailContent(
                            subject=email_data['subject'],
                            body=body,
                            sender=email_data['from'],
                            recipient=email_data.get('to', ''),
                            received_date=received_date,
                            domain=domain
                        )
                        
                        emails.append(email_content)
                        
                except Exception as e:
                    print(f"Error processing message {message['id']}: {e}")
                    continue
            
            return emails
            
        except HttpError as e:
            raise EmailProcessingException(f"Failed to fetch emails: {str(e)}")
    
    def _extract_body(self, payload: Dict[str, Any]) -> str:
        """Extract email body from payload."""
        body = ""
        
        if 'parts' in payload:
            for part in payload['parts']:
                if part['mimeType'] == 'text/plain':
                    data = part['body'].get('data', '')
                    if data:
                        body += base64.urlsafe_b64decode(data).decode('utf-8')
                elif part['mimeType'] == 'text/html' and not body:
                    data = part['body'].get('data', '')
                    if data:
                        body += base64.urlsafe_b64decode(data).decode('utf-8')
        else:
            if payload['mimeType'] == 'text/plain':
                data = payload['body'].get('data', '')
                if data:
                    body = base64.urlsafe_b64decode(data).decode('utf-8')
            elif payload['mimeType'] == 'text/html':
                data = payload['body'].get('data', '')
                if data:
                    body = base64.urlsafe_b64decode(data).decode('utf-8')
        
        return body.strip()
    
    def send_email(self, to: str, subject: str, body: str) -> bool:
        """Send email via Gmail."""
        if not self.is_authenticated():
            raise EmailProcessingException("Not authenticated with Gmail")
        
        try:
            message = MIMEText(body)
            message['to'] = to
            message['subject'] = subject
            
            raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode('utf-8')
            
            self.service.users().messages().send(
                userId='me',
                body={'raw': raw_message}
            ).execute()
            
            return True
            
        except HttpError as e:
            raise EmailProcessingException(f"Failed to send email: {str(e)}")
    
    def get_domains(self, emails: List[EmailContent]) -> List[EmailDomain]:
        """Analyze email domains and return domain statistics."""
        domain_stats = {}
        
        for email in emails:
            domain = email.domain
            if domain not in domain_stats:
                domain_stats[domain] = {
                    'count': 0,
                    'last_received': email.received_date,
                    'importance_score': 0.5  # Default importance
                }
            
            domain_stats[domain]['count'] += 1
            if email.received_date > domain_stats[domain]['last_received']:
                domain_stats[domain]['last_received'] = email.received_date
        
        # Calculate importance scores based on frequency and recency
        total_emails = len(emails)
        for domain, stats in domain_stats.items():
            frequency_score = stats['count'] / total_emails
            recency_score = 1.0 if stats['last_received'] > datetime.now() - timedelta(days=7) else 0.5
            stats['importance_score'] = (frequency_score * 0.7) + (recency_score * 0.3)
        
        return [
            EmailDomain(
                domain=domain,
                count=stats['count'],
                importance_score=stats['importance_score'],
                last_received=stats['last_received']
            )
            for domain, stats in domain_stats.items()
        ]
    
    def logout(self):
        """Logout and clear all stored credentials."""
        self._clear_sessions()
        self.service = None
        print("✅ Gmail service logged out and sessions cleared")
